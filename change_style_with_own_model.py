# -*- coding: utf-8 -*-
"""change_style_with_resnet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jErPJo24EnrzghDH0mavwlzleiOswlMv
"""

import torch, torchvision
from torch import nn
from PIL import Image

import os,sys,getopt
import time,datetime,pytz

#from google.colab import drive 

def get_device(i=0):
    """Return gpu(i) if exists, otherwise return cpu().
    Defined in :numref:`sec_use_gpu`"""
    if torch.cuda.device_count() >= i + 1:
        return torch.device(f'cuda:{i}')
    return torch.device('cpu')

#----------- get the contents and styles -----------
def extract_features(X, net, content_layers, style_layers):
    contents = []
    styles = []
    for i in range(len(net)):
        X = net[i](X)
        if i in style_layers:
            styles.append(X)
        if i in content_layers:
            contents.append(X)
    return contents, styles

def get_contents(content_img, image_shape, content_layers, style_layers, net, device):
    content_X = preProcess(content_img, image_shape).to(device)
    content_Y, _ = extract_features(content_X, net, content_layers, style_layers)
    return content_X, content_Y

def get_styles(style_img, image_shape, content_layers, style_layers, net, device):
    style_X = preProcess(style_img, image_shape).to(device)
    _, style_Y = extract_features(style_X, net, content_layers, style_layers)
    return style_X, style_Y


#---------- define the loss function ---------
def content_loss(Y_hat, Y):
    return torch.square(Y_hat - Y.detach()).mean()

def gram(X):
    num_channels, n = X.shape[1], X.numel()//X.shape[1]
    X = X.reshape((num_channels, n))
    return torch.matmul(X, X.T)/(num_channels * n)

def style_loss(Y_hat, gram_Y):
    return torch.square(gram(Y_hat) - gram_Y.detach()).mean()

def tv_loss(Y_hat):
    return 0.5 * (torch.abs(Y_hat[:,:,1:,:] - Y_hat[:, :, :-1,:]).mean() +
                  torch.abs(Y_hat[:,:,:,1:] - Y_hat[:, :, : , :-1]).mean())


def compute_loss(X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram):
    contents_l = [content_loss(Y_hat, Y) * content_weight for Y_hat, Y in zip(
        contents_Y_hat, contents_Y)]
    styles_l = [style_loss(Y_hat, Y) * style_weight for Y_hat, Y in zip(
        styles_Y_hat, styles_Y_gram)]
    tv_l = tv_loss(X) * tv_weight
    l = sum(10 * styles_l + contents_l + [tv_l])
    return contents_l, styles_l, tv_l, l


#--------------------------------------------------


class SynthesizedImage(nn.Module):
    def __init__(self, image_shape, **kwargs):
        super(SynthesizedImage, self).__init__(**kwargs)
        self.weight = nn.Parameter(torch.rand(*image_shape))

    def forward(self):
        return self.weight

def get_inits(X, device, lr, styles_Y):
    gen_img = SynthesizedImage(X.shape).to(device)
    gen_img.weight.data.copy_(X.data)
    trainer = torch.optim.Adam(gen_img.parameters(), lr=lr)
    styles_Y_gram = [gram(Y) for Y in styles_Y]
    return gen_img(), styles_Y_gram, trainer

def train(X, net, contents_Y, styles_Y, contents_layer, styles_layer, device, lr, num_epochs, lr_decay_epoch):
    X, styles_Y_gram, trainer = get_inits(X, device, lr, styles_Y)
    scheduler = torch.optim.lr_scheduler.StepLR(trainer, lr_decay_epoch, 0.8)
    for epoch in range(num_epochs):
        trainer.zero_grad()
        contents_Y_hat, styles_Y_hat = extract_features(
            X, net, contents_layer, styles_layer)
        contents_l, styles_l, tv_l, l = compute_loss(
            X, contents_Y_hat, styles_Y_hat, contents_Y, styles_Y_gram)
        l.backward()
        trainer.step()
        scheduler.step()
        if (epoch + 1) % 100 ==0:
            print(f"contents_l {sum(contents_l):.3f}, styles_l {sum(styles_l):.3f}, tv_l {tv_l:.3f}")
            postProcess(X)
    return X
        
                        

#----------------------------------------------
rgb_mean = torch.tensor([0.485, 0.456, 0.406])
rgb_std = torch.tensor([0.229, 0.224, 0.225])

def preProcess(img, image_shape):
    transforms = torchvision.transforms.Compose([
        torchvision.transforms.Resize(image_shape),
        torchvision.transforms.ToTensor(),
        torchvision.transforms.Normalize(mean=rgb_mean, std=rgb_std)])
    return transforms(img).unsqueeze(0)
                                                

def postProcess(img):
    shanghai = pytz.timezone("Asia/Shanghai")
    now = datetime.datetime.now(shanghai)
    fmt = '%Y%m%d_%H%M%S'
    s = (now.strftime(fmt))[2:]
    file_name = 'output/' + s + '.jpeg'
    img = img[0].to(rgb_std.device)
    img = torch.clamp(img.permute(1, 2, 0) * rgb_std + rgb_mean, 0, 1)
    pic = torchvision.transforms.ToPILImage()(img.permute(2, 0, 1))
    pic.save(file_name)

# ----------- 新增ResNet ---------
def init_weights(m):
  if type(m) == nn.Linear or type(m) == nn.Conv2d:
    nn.init.xavier_uniform_(m.weight)

class Residual(nn.Module):
    def __init__(self, input_channels, num_channels, use_1x1conv=False,
                 strides=1):
        super().__init__()
        self.conv1 = nn.Conv2d(input_channels, num_channels, 
                               kernel_size=3, padding=1, stride=strides)
        self.conv2 = nn.Conv2d(num_channels, num_channels,
                               kernel_size=3, padding=1)
        if use_1x1conv:
            self.conv3 = nn.Conv2d(input_channels, num_channels,
                                   kernel_size=1, stride=strides)
        else:
            self.conv3 = None
        self.bn1 = nn.BatchNorm2d(num_channels)
        self.bn2 = nn.BatchNorm2d(num_channels)

    def forward(self, X):
        Y = nn.functional.relu(self.bn1(self.conv1(X)))
        Y = self.bn2(self.conv2(Y))
        if self.conv3:
            X = self.conv3(X)
        Y = Y + X
        return nn.functional.relu(Y)

def resnet_block(input_channels, num_channels, num_residuals,
                 first_block=False):
    blk = []
    for i in range(num_residuals):
        if i == 0 and not first_block:
            blk.append(Residual(input_channels, num_channels,
                                use_1x1conv=True, strides=2))
        else:
            blk.append(Residual(num_channels, num_channels))
    return blk


def create_ResNet():
    b1 = nn.Sequential(nn.Conv2d(3, 64, kernel_size=7, stride=2, padding=3),
                                 nn.BatchNorm2d(64), nn.ReLU(), 
                                 nn.MaxPool2d(kernel_size=3, stride=2, 
                                              padding=1))
    b2 = nn.Sequential(*resnet_block(64, 64, 2, first_block=True))
    b3 = nn.Sequential(*resnet_block(64, 128, 2))
    b4 = nn.Sequential(*resnet_block(128, 256, 2))
    b5 = nn.Sequential(*resnet_block(256, 512, 2))
    net = nn.Sequential(b1, b2, b3, b4, b5, 
                        nn.AdaptiveAvgPool2d((1, 1)),
                        nn.Flatten(), nn.Linear(512, 10))
    X = torch.rand(size=(1, 3, 224, 224))
    for layer in net:
        X = layer(X)
        print(layer.__class__.__name__,'output shape:\t', X.shape)

    net.apply(init_weights)
    return "ResNet", net


def load_model(path, model_name, net):
    epoch = 0
    data_set_name = None
    for file_name in os.listdir(path):
        if (model_name in file_name) and ("checkpoint.pth" in file_name):
            target_name = path + "/" + file_name
            checkpoint = torch.load(target_name, map_location=get_device())
            if not model_name == checkpoint['model_name']:
                continue
            net.load_state_dict(checkpoint['model_state_dict'])
            epoch = checkpoint['epoch']
            test_acc = checkpoint['test_acc']
            train_acc = checkpoint['train_acc']
            loss = checkpoint['loss']
            data_set_name = checkpoint['data_set_name']
            print("Load model ", file_name, f": model={model_name}, epoch={epoch}")
            print(f"Load this model with loss={loss:.3f}, test_acc={test_acc:.3f}, train_acc={train_acc:.3f}")
            return epoch, data_set_name
    return epoch, data_set_name

# ---- Good for ResNet ------
content_weight, style_weight, tv_weight = 6000, 100000000, 10


def main(argv):
    try:
        opts, args = getopt.getopt(argv,"hi:s:",["input=","style="])
    except getopt.GetoptError:
        print('pytorch_eval.py -i <input_photograph> -s <style_picture>')
        sys.exit(2)

    for opt, arg in opts:
        if opt == ('-h'):
            print('pytorch_eval.py -i <input_photograph> -s <style_picture>')
            sys.exit()
        elif opt in ("-i", "--input"):
            content_img_file = arg
        elif opt in ("-s", "--style"):
            style_img_file = arg

    try:
        os.makedirs("output")
    except Exception as e:
        e = e

    #drive.mount('/content/drive')

    device = get_device()
    image_shape = (300,450)


    #pretrained_net = torchvision.models.vgg19(pretrained=True)
    _, pretrained_net = create_ResNet()
    _, _ = load_model("./model/", "ResNet" , pretrained_net)

    #style_layers, content_layers = [0, 5, 10, 19, 28], [25]
    #net = nn.Sequential(*[pretrained_net.features[i] for i in
    #                      range(max(content_layers + style_layers) + 1)]).to(device)
    style_layers, content_layers = [0,1,2, 3 ,4], [3]
    net = nn.Sequential(*[pretrained_net[i] for i in
                          range(max(content_layers + style_layers) + 1)]).to(device)


    content_img = Image.open(content_img_file)
    style_img = Image.open(style_img_file)

    content_X, content_Y = get_contents(content_img, image_shape, content_layers, style_layers, net, device)
    _, styles_Y = get_styles(style_img, image_shape, content_layers, style_layers, net, device)
    output = train(content_X, net,  content_Y, styles_Y, content_layers, style_layers, device, 0.3, 200, 50)




if __name__ == "__main__":
    print("call main")
    main(sys.argv[1:])
    print("main finished")

